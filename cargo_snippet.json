{
  "binary_search": {
    "prefix": "binary_search",
    "body": [
      "pub fn binary_search<T, F>(vec: &Vec<T>, key: T, is_ok: F) -> usize",
      "where",
      "    F: Fn(usize, T, &Vec<T>) -> bool,",
      "    T: PartialOrd + Copy,",
      "{",
      "    let mut ng = -1;",
      "    let mut ok = vec.len() as isize;",
      "    while (ok - ng).abs() > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        if is_ok(mid as usize, key, vec) {",
      "            ok = mid",
      "        } else {",
      "            ng = mid",
      "        }",
      "    }",
      "    return ok as usize;",
      "}"
    ]
  },
  "calc_comb": {
    "prefix": "calc_comb",
    "body": [
      "#[derive(Debug, Clone)]",
      "pub struct Combination {",
      "    fact_inv: Vec<usize>,",
      "    inv: Vec<usize>,",
      "    com: Option<Vec<usize>>,",
      "    m: usize,",
      "}",
      "impl Combination {",
      "    pub fn new(upper: usize, m: usize) -> Self {",
      "        let mut fact_inv = vec![0; upper + 1];",
      "        let mut inv = vec![0; upper + 1];",
      "        fact_inv[0] = 1;",
      "        fact_inv[1] = 1;",
      "        inv[1] = 1;",
      "        for i in 2..=upper {",
      "            inv[i] = m - inv[m % i] * (m / i) % m;",
      "            fact_inv[i] = fact_inv[i - 1] * inv[i] % m;",
      "        }",
      "        Self {",
      "            fact_inv: fact_inv,",
      "            inv: inv,",
      "            com: None,",
      "            m: m,",
      "        }",
      "    }",
      "    pub fn fix_n(&mut self, n: usize) {",
      "        let mut com = vec![0; n + 1];",
      "        com[0] = 1;",
      "        for i in 1..=n {",
      "            com[i] = com[i - 1] * ((n - i + 1) * self.inv[i] % self.m) % self.m;",
      "        }",
      "        self.com = Some(com)",
      "    }",
      "    fn _calc_nck(&self, n: usize, k: usize) -> usize {",
      "        if n < k {",
      "            return 0;",
      "        }",
      "        let mut ans: usize = 1;",
      "        let mut i = n;",
      "        while n - k < i {",
      "            ans *= i;",
      "            ans %= self.m;",
      "            i -= 1;",
      "        }",
      "        ans * self.fact_inv[k] % self.m",
      "    }",
      "    pub fn nck(&self, n: usize, k: usize) -> usize {",
      "        match self.com.clone() {",
      "            None => self._calc_nck(n, k),",
      "            Some(x) => x[k],",
      "        }",
      "    }",
      "    pub fn nhk(&self, n: usize, k: usize) -> usize {",
      "        if self.fact_inv.len() < n + k - 1 {",
      "            panic!(\"length must be n+k-1 or larger!\")",
      "        }",
      "        self.nck(n + k - 1, k)",
      "    }",
      "}"
    ]
  },
  "chmax!": {
    "prefix": "chmax!",
    "body": [
      "macro_rules !max {(\\$a :expr \\$(,) *) =>{{\\$a } } ;(\\$a :expr ,\\$b :expr \\$(,) *) =>{{std ::cmp ::max (\\$a ,\\$b ) } } ;(\\$a :expr ,\\$(\\$rest :expr ) ,+\\$(,) *) =>{{std ::cmp ::max (\\$a ,max !(\\$(\\$rest ) ,+) ) } } ;}",
      "macro_rules !chmax {(\\$base :expr ,\\$(\\$cmps :expr ) ,+\\$(,) *) =>{{let cmp_max =max !(\\$(\\$cmps ) ,+) ;if \\$base <cmp_max {\\$base =cmp_max ;true ;} else {false ;} } } ;}"
    ]
  },
  "chmin!": {
    "prefix": "chmin!",
    "body": [
      "macro_rules !min {(\\$a :expr \\$(,) *) =>{{\\$a } } ;(\\$a :expr ,\\$b :expr \\$(,) *) =>{{std ::cmp ::min (\\$a ,\\$b ) } } ;(\\$a :expr ,\\$(\\$rest :expr ) ,+\\$(,) *) =>{{std ::cmp ::min (\\$a ,min !(\\$(\\$rest ) ,+) ) } } ;}",
      "macro_rules !chmin {(\\$base :expr ,\\$(\\$cmps :expr ) ,+\\$(,) *) =>{{let cmp_min =min !(\\$(\\$cmps ) ,+) ;if \\$base >cmp_min {\\$base =cmp_min ;true ;} else {false ;} } } ;}"
    ]
  },
  "enum_divisors": {
    "prefix": "enum_divisors",
    "body": [
      "pub fn enum_divisors<T: PrimInt + NumAssign>(n: T) -> Vec<T> {",
      "    let mut res: Vec<T> = Vec::new();",
      "    let mut i: T = one();",
      "    while i * i <= n {",
      "        if n % i == zero() {",
      "            res.push(i);",
      "            if n / i != i {",
      "                res.push(n / i)",
      "            }",
      "        }",
      "        i += one();",
      "    }",
      "    res.sort();",
      "    res",
      "}"
    ]
  },
  "gcd": {
    "prefix": "gcd",
    "body": [
      "pub fn gcd<T: PrimInt>(a: T, b: T) -> T {",
      "    if b == zero() {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}"
    ]
  },
  "gcd_list": {
    "prefix": "gcd_list",
    "body": [
      "pub fn gcd<T: PrimInt>(a: T, b: T) -> T {",
      "    if b == zero() {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}",
      "pub fn gcd_list<T: PrimInt>(vec: Vec<T>) -> T {",
      "    assert!(vec.len() > 1);",
      "    vec.iter().fold(vec[0], |acc, x| gcd(*x, acc))",
      "}"
    ]
  },
  "is_prime": {
    "prefix": "is_prime",
    "body": [
      "pub fn is_prime<T: PrimInt + NumAssign>(n: T) -> bool {",
      "    let mut flag: bool = true;",
      "    if n == one() {",
      "        flag = false",
      "    }",
      "    let mut i: T = one::<T>().signed_shl(1);",
      "    while i * i <= n {",
      "        if n % i == zero() {",
      "            flag = false;",
      "            break;",
      "        }",
      "        i += one();",
      "    }",
      "    flag",
      "}"
    ]
  },
  "lcm": {
    "prefix": "lcm",
    "body": [
      "pub fn gcd<T: PrimInt>(a: T, b: T) -> T {",
      "    if b == zero() {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}",
      "pub fn lcm<T: PrimInt>(a: T, b: T) -> T {",
      "    a / gcd(a, b) * b",
      "}"
    ]
  },
  "lcm_list": {
    "prefix": "lcm_list",
    "body": [
      "pub fn lcm<T: PrimInt>(a: T, b: T) -> T {",
      "    a / gcd(a, b) * b",
      "}",
      "pub fn gcd<T: PrimInt>(a: T, b: T) -> T {",
      "    if b == zero() {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}",
      "pub fn lcm_list<T: PrimInt>(vec: Vec<T>) -> T {",
      "    assert!(vec.len() > 1);",
      "    vec.iter().fold(vec[0], |acc, x| lcm(*x, acc))",
      "}"
    ]
  },
  "max!": {
    "prefix": "max!",
    "body": [
      "macro_rules !max {(\\$a :expr \\$(,) *) =>{{\\$a } } ;(\\$a :expr ,\\$b :expr \\$(,) *) =>{{std ::cmp ::max (\\$a ,\\$b ) } } ;(\\$a :expr ,\\$(\\$rest :expr ) ,+\\$(,) *) =>{{std ::cmp ::max (\\$a ,max !(\\$(\\$rest ) ,+) ) } } ;}"
    ]
  },
  "min!": {
    "prefix": "min!",
    "body": [
      "macro_rules !min {(\\$a :expr \\$(,) *) =>{{\\$a } } ;(\\$a :expr ,\\$b :expr \\$(,) *) =>{{std ::cmp ::min (\\$a ,\\$b ) } } ;(\\$a :expr ,\\$(\\$rest :expr ) ,+\\$(,) *) =>{{std ::cmp ::min (\\$a ,min !(\\$(\\$rest ) ,+) ) } } ;}"
    ]
  },
  "mod_int": {
    "prefix": "mod_int",
    "body": [
      "pub mod mod_int {",
      "    use std::ops::{",
      "        Add, AddAssign, BitAnd, Div, DivAssign, Mul, MulAssign, RemAssign, ShrAssign, Sub,",
      "        SubAssign,",
      "    };",
      "    pub struct ModInt<T> {",
      "        v: T,",
      "        m: T,",
      "    }",
      "    impl<T> ModInt<T>",
      "    where",
      "        T: Copy,",
      "    {",
      "        pub fn value(&self) -> T {",
      "            self.v",
      "        }",
      "        pub fn modulo(&self) -> T {",
      "            self.m",
      "        }",
      "    }",
      "    impl<T> ModInt<T> {",
      "        fn new_unchecked(v: T, modulo: T) -> Self {",
      "            Self { v, m: modulo }",
      "        }",
      "    }",
      "    impl<T> ModInt<T>",
      "    where",
      "        T: Copy + RemAssign + PartialOrd,",
      "    {",
      "        pub fn new(mut v: T, modulo: T) -> Self {",
      "            if v >= modulo {",
      "                v %= modulo;",
      "            }",
      "            Self::new_unchecked(v, modulo)",
      "        }",
      "    }",
      "    impl<T> ModInt<T>",
      "    where",
      "        T: Copy",
      "            + Sub<Output = T>",
      "            + ShrAssign",
      "            + BitAnd<Output = T>",
      "            + PartialEq",
      "            + PartialOrd",
      "            + Div<Output = T>",
      "            + RemAssign,",
      "        ModInt<T>: MulAssign,",
      "    {",
      "        pub fn pow(self, e: T) -> Self {",
      "            let zero = self.modulo() - self.modulo();",
      "            let one = self.modulo() / self.modulo();",
      "            let mut e = e;",
      "            let mut result = Self::new_unchecked(one, self.modulo());",
      "            let mut cur = self;",
      "            while e > zero {",
      "                if e & one == one {",
      "                    result *= cur;",
      "                }",
      "                e >>= one;",
      "                cur *= cur;",
      "            }",
      "            result",
      "        }",
      "    }",
      "    impl<T> Copy for ModInt<T> where T: Copy {}",
      "    impl<T> Clone for ModInt<T>",
      "    where",
      "        T: Copy,",
      "    {",
      "        fn clone(&self) -> Self {",
      "            Self::new_unchecked(self.value(), self.modulo())",
      "        }",
      "    }",
      "    impl<T> Add<T> for ModInt<T>",
      "    where",
      "        T: AddAssign + SubAssign + RemAssign + Copy + PartialOrd,",
      "    {",
      "        type Output = Self;",
      "        fn add(self, mut rhs: T) -> Self::Output {",
      "            if rhs >= self.modulo() {",
      "                rhs %= self.modulo();",
      "            }",
      "            rhs += self.value();",
      "            if rhs >= self.modulo() {",
      "                rhs -= self.modulo();",
      "            }",
      "            Self::new_unchecked(rhs, self.modulo())",
      "        }",
      "    }",
      "    impl<T> Sub<T> for ModInt<T>",
      "    where",
      "        T: AddAssign + SubAssign + RemAssign + Copy + PartialOrd,",
      "    {",
      "        type Output = Self;",
      "        fn sub(self, mut rhs: T) -> Self::Output {",
      "            if rhs >= self.modulo() {",
      "                rhs %= self.modulo();",
      "            }",
      "            let mut result = self.value();",
      "            result += self.modulo();",
      "            result -= rhs;",
      "            if result >= self.modulo() {",
      "                result -= self.modulo();",
      "            }",
      "            Self::new_unchecked(result, self.modulo())",
      "        }",
      "    }",
      "    impl<T> Mul<T> for ModInt<T>",
      "    where",
      "        T: MulAssign + RemAssign + Copy + PartialOrd,",
      "    {",
      "        type Output = Self;",
      "        fn mul(self, mut rhs: T) -> Self::Output {",
      "            if rhs >= self.modulo() {",
      "                rhs %= self.modulo();",
      "            }",
      "            rhs *= self.value();",
      "            rhs %= self.modulo();",
      "            Self::new_unchecked(rhs, self.modulo())",
      "        }",
      "    }",
      "    impl<T> Add<ModInt<T>> for ModInt<T>",
      "    where",
      "        T: Copy,",
      "        ModInt<T>: Add<T, Output = ModInt<T>>,",
      "    {",
      "        type Output = Self;",
      "        fn add(self, rhs: ModInt<T>) -> Self::Output {",
      "            self + rhs.value()",
      "        }",
      "    }",
      "    impl<T> Sub<ModInt<T>> for ModInt<T>",
      "    where",
      "        T: Copy,",
      "        ModInt<T>: Sub<T, Output = ModInt<T>>,",
      "    {",
      "        type Output = Self;",
      "        fn sub(self, rhs: ModInt<T>) -> Self::Output {",
      "            self - rhs.value()",
      "        }",
      "    }",
      "    impl<T> Mul<ModInt<T>> for ModInt<T>",
      "    where",
      "        T: Copy,",
      "        ModInt<T>: Mul<T, Output = ModInt<T>>,",
      "    {",
      "        type Output = Self;",
      "        fn mul(self, rhs: ModInt<T>) -> Self::Output {",
      "            self * rhs.value()",
      "        }",
      "    }",
      "    impl<T> Div<ModInt<T>> for ModInt<T>",
      "    where",
      "        T: Copy,",
      "        ModInt<T>: Div<T, Output = ModInt<T>>,",
      "    {",
      "        type Output = Self;",
      "        fn div(self, rhs: ModInt<T>) -> Self::Output {",
      "            self / rhs.value()",
      "        }",
      "    }",
      "    impl<T> AddAssign<T> for ModInt<T>",
      "    where",
      "        T: Copy,",
      "        ModInt<T>: Add<T, Output = ModInt<T>>,",
      "    {",
      "        fn add_assign(&mut self, other: T) {",
      "            *self = *self + other;",
      "        }",
      "    }",
      "    impl<T> AddAssign<ModInt<T>> for ModInt<T>",
      "    where",
      "        T: Copy,",
      "        ModInt<T>: Add<ModInt<T>, Output = ModInt<T>>,",
      "    {",
      "        fn add_assign(&mut self, other: ModInt<T>) {",
      "            *self = *self + other;",
      "        }",
      "    }",
      "    impl<T> SubAssign<T> for ModInt<T>",
      "    where",
      "        T: Copy,",
      "        ModInt<T>: Sub<T, Output = ModInt<T>>,",
      "    {",
      "        fn sub_assign(&mut self, other: T) {",
      "            *self = *self - other;",
      "        }",
      "    }",
      "    impl<T> SubAssign<ModInt<T>> for ModInt<T>",
      "    where",
      "        T: Copy,",
      "        ModInt<T>: Sub<ModInt<T>, Output = ModInt<T>>,",
      "    {",
      "        fn sub_assign(&mut self, other: ModInt<T>) {",
      "            *self = *self - other;",
      "        }",
      "    }",
      "    impl<T> DivAssign<T> for ModInt<T>",
      "    where",
      "        T: Copy,",
      "        ModInt<T>: Div<T, Output = ModInt<T>>,",
      "    {",
      "        fn div_assign(&mut self, rhs: T) {",
      "            *self = *self / rhs",
      "        }",
      "    }",
      "    impl<T> DivAssign<ModInt<T>> for ModInt<T>",
      "    where",
      "        T: Copy,",
      "        ModInt<T>: Div<ModInt<T>, Output = ModInt<T>>,",
      "    {",
      "        fn div_assign(&mut self, rhs: ModInt<T>) {",
      "            *self = *self / rhs",
      "        }",
      "    }",
      "    impl<T> MulAssign<T> for ModInt<T>",
      "    where",
      "        T: Copy,",
      "        ModInt<T>: Mul<T, Output = ModInt<T>>,",
      "    {",
      "        fn mul_assign(&mut self, rhs: T) {",
      "            *self = *self * rhs;",
      "        }",
      "    }",
      "    impl<T> MulAssign<ModInt<T>> for ModInt<T>",
      "    where",
      "        T: Copy,",
      "        ModInt<T>: Mul<ModInt<T>, Output = ModInt<T>>,",
      "    {",
      "        fn mul_assign(&mut self, rhs: ModInt<T>) {",
      "            *self = *self * rhs;",
      "        }",
      "    }",
      "    impl<T> Div<T> for ModInt<T>",
      "    where",
      "        T: Copy",
      "            + Add<Output = T>",
      "            + Sub<Output = T>",
      "            + Div<Output = T>",
      "            + BitAnd<Output = T>",
      "            + PartialEq",
      "            + PartialOrd",
      "            + ShrAssign",
      "            + RemAssign",
      "            + MulAssign,",
      "    {",
      "        type Output = Self;",
      "        fn div(self, mut rhs: T) -> Self::Output {",
      "            if rhs >= self.modulo() {",
      "                rhs %= self.modulo();",
      "            }",
      "            let one = self.modulo() / self.modulo();",
      "            let two = one + one;",
      "            self * Self::new_unchecked(rhs, self.modulo()).pow(self.modulo() - two)",
      "        }",
      "    }",
      "}"
    ]
  },
  "prime_factorize": {
    "prefix": "prime_factorize",
    "body": [
      "pub fn prime_factorize<T: PrimInt + NumAssign>(mut n: T) -> Vec<(T, T)> {",
      "    let mut res: Vec<(T, T)> = Vec::new();",
      "    let mut i: T = one::<T>().signed_shl(1);",
      "    while i * i <= n {",
      "        if n % i == zero() {",
      "            let mut ex = zero::<T>();",
      "            while n % i == zero() {",
      "                ex += one();",
      "                n = n / i;",
      "            }",
      "            res.push((i, ex));",
      "        }",
      "        i += one();",
      "    }",
      "    if n != one() {",
      "        res.push((n, one()))",
      "    }",
      "    res",
      "}"
    ]
  },
  "sieve_of_eratosthenes": {
    "prefix": "sieve_of_eratosthenes",
    "body": [
      "pub fn sieve_of_eratosthenes<T: NumCast>(n: T) -> Vec<usize> {",
      "    let n = match n.to_usize() {",
      "        Some(x) => x,",
      "        None => panic!(\"n should be u8, u16, u32, u64, u128, usize or positive number!\"),",
      "    };",
      "    let mut primes = vec![];",
      "    let mut list_dequeue: std::collections::VecDeque<usize> = (2..=n).collect();",
      "    if n < 2 {",
      "        return primes;",
      "    }",
      "    if n == 2 {",
      "        return vec![2];",
      "    }",
      "    while list_dequeue.front().unwrap().pow(2) <= n {",
      "        let first = list_dequeue.pop_front().unwrap();",
      "        primes.push(first);",
      "        list_dequeue = list_dequeue",
      "            .into_iter()",
      "            .filter(|&x| x % first != 0)",
      "            .collect();",
      "    }",
      "    let mut list_vec = list_dequeue.into_iter().collect::<Vec<usize>>();",
      "    primes.append(&mut list_vec);",
      "    primes",
      "}"
    ]
  },
  "struct_comb": {
    "prefix": "struct_comb",
    "body": [
      "#[derive(Debug, Clone)]",
      "pub struct Combination {",
      "    fact_inv: Vec<usize>,",
      "    inv: Vec<usize>,",
      "    com: Option<Vec<usize>>,",
      "    m: usize,",
      "}"
    ]
  }
}
